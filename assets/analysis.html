<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse - Funksjonell Skulderscreening</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Avenir:wght@400;700&family=Futura:wght@400;500;700&display=swap">

    <style>
        /* --- CSS Variables (Beholdt for Plotly og egendefinerte stiler) --- */
        :root {
            --primary-color: #005f73;
            --secondary-color: #0a9396;
            --accent-color: #ee9b00;
            --light-gray: #f8f9fa; /* Used for plot background */
            --medium-gray: #dee2e6; /* Used for gridlines */
            --dark-gray: #495057;
            --text-color: #212529;
            --success-color: #16a34a;
            --danger-color-light: #e85d04;
            --danger-color-dark: #dc2626;
            --white: #ffffff; /* Used for paper background */
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            /* --- Matplotlib Default Colors --- */
            --left-line-color-matplotlib: #1f77b4; /* Matplotlib Blue */
            --right-line-color-matplotlib: #ff7f0e; /* Matplotlib Orange */
            --left-bg-color-transparent-matplotlib: rgba(31, 119, 180, 0.1); /* Transparent Matplotlib Blue */
            --right-bg-color-transparent-matplotlib: rgba(255, 127, 14, 0.1); /* Transparent Matplotlib Orange */
            /* --- End Matplotlib Default Colors --- */
            --norm-poor-bg: rgba(252, 165, 165, 0.5);
            --norm-average-bg: rgba(252, 211, 77, 0.5);
            --norm-good-bg: rgba(167, 243, 208, 0.5);
            --norm-excellent-bg: rgba(52, 211, 153, 0.5);
        }
        /* Bruker Avenir/Inter som fallback */
        body { font-family: 'Avenir', 'Inter', sans-serif; background-color: #f8fafc; /* bg-slate-50 */ }
        .container { background-color: #ffffff; } /* bg-white */

        /* Egendefinerte stiler for elementer som ikke dekkes fullt av Tailwind-klasser fra React-koden */
        .file-input-button { background-color: #0d9488; /* teal-600 */ color: white; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; font-weight: 600; display: inline-block; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .file-input-button:hover { background-color: #0f766e; /* teal-700 */ transform: translateY(-1px); }
        #upload-csv { display: none; } /* Skjuler standard fil-input */

        .patient-button {
            transition: all 0.2s ease-in-out;
            background-color: #f0fdfa; /* teal-50 */ border-color: #5eead4; /* teal-300 */ color: #115e59; /* teal-800 */
            font-weight: 500; border-width: 1px; padding: 0.5rem 1rem; /* py-2 px-4 */
            border-radius: 0.375rem; /* rounded-md */ box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); /* shadow-sm */
            font-size: 0.875rem; /* text-sm */
        }
        .patient-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(13, 148, 136, 0.2);
            border-color: #0d9488; /* teal-600 */ background-color: #ccfbf1; /* teal-100 */
        }
        .patient-button.selected {
            background-color: #0f766e; /* teal-700 */ color: white; border-color: #042f2e; /* teal-800 */
            transform: translateY(0); box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .patient-button.selected:hover { box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }

        .view-toggle-button {
            transition: all 0.2s ease-in-out; border-width: 1px; font-weight: 500;
            padding: 0.25rem 0.75rem; /* py-1 px-3 */ font-size: 0.875rem; /* text-sm */
        }
        .view-toggle-button.active {
            background-color: #14b8a6; /* teal-500 */ color: white; border-color: #0f766e; /* teal-700 */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .view-toggle-button:not(.active) {
             background-color: #f1f5f9; /* slate-100 */ border-color: #cbd5e1; /* slate-300 */ color: #475569; /* slate-700 */
        }
        .view-toggle-button:not(.active):hover { background-color: #e2e8f0; /* slate-200 */ border-color: #94a3b8; /* slate-400 */ }

        .info-box { background-color: #f8fafc; /* slate-50 */ border: 1px solid #e2e8f0; /* slate-200 */ border-radius: 0.5rem; /* rounded-lg */ padding: 1.5rem; /* p-6 */ margin-bottom: 1.5rem; /* mb-6 */ }

        .graph-box { background-color: #ffffff; /* bg-white */ border: 1px solid #e2e8f0; /* slate-200 */ border-radius: 0.75rem; /* rounded-xl */ padding: 1rem; /* p-4 */ margin-bottom: 2rem; /* mb-8 */ box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* shadow-md */ }
        .graph-box-title { color: #0f766e; /* teal-700 */ font-size: 1.125rem; /* text-lg */ font-weight: 700; /* font-bold */ margin-bottom: 1rem; /* mb-4 */ padding-bottom: 0.5rem; /* pb-2 */ border-bottom: 1px solid #cbd5e1; /* slate-300 */ font-family: 'Futura', 'Inter', sans-serif; }

        .plotly-graph-div { min-height: 350px; width: 100%; }
        .loading-placeholder { display: flex; align-items: center; justify-content: center; height: 100%; color: #64748b; /* slate-500 */ font-style: italic; }
        .error-message { color: #dc2626; /* red-600 */ font-weight: 600; }

        /* Summary Table Styles */
        .summary-table { width: 100%; border-collapse: collapse; margin-top: 1rem; font-size: 0.875rem; /* text-sm */ table-layout: fixed; }
        .summary-table th, .summary-table td { border: 1px solid #e2e8f0; /* slate-200 */ padding: 0.375rem 0.5rem; /* py-1.5 px-2 */ text-align: center; vertical-align: middle; white-space: nowrap; }
        .summary-table th { background-color: #f1f5f9; /* slate-100 */ font-weight: 600; color: #1e293b; /* slate-800 */ }
        .summary-table .metric-header { width: 140px; text-align: left; font-weight: bold; background-color: #f8fafc; /* slate-50 */ padding-left: 0.75rem; /* pl-3 */ position: sticky; left: 0; z-index: 10; }
        .summary-table .date-header { background-color: #f8fafc; /* slate-50 */ font-weight: bold; text-align: center; }
        .summary-table .sub-header { background-color: #f1f5f9; /* slate-100 */ font-weight: 500; font-size: 0.75rem; /* text-xs */ color: #475569; /* slate-600 */ padding: 0.25rem; /* p-1 */ }
        .summary-table .metric-label { text-align: left; font-weight: 500; padding-left: 1rem; /* pl-4 */ background-color: #f8fafc; /* slate-50 */ position: sticky; left: 0; z-index: 10; }
        .summary-table .left-value-cell { background-color: var(--left-bg-color-transparent-matplotlib); /* bg-blue-50 */ }
        .summary-table .right-value-cell { background-color: var(--right-bg-color-transparent-matplotlib); /* bg-orange-50 */ }
        .summary-table .change-pos { color: #16a34a; /* green-600 */ }
        .summary-table .change-neg { color: #dc2626; /* red-600 */ }
        .summary-table .change-zero { color: #64748b; /* slate-500 */ }
        .summary-table .na { color: #94a3b8; /* slate-400 */ font-style: italic; }

        .summary-section + .summary-section { margin-top: 2.5rem; }
        .summary-section-title { color: #0f766e; /* teal-700 */ font-size: 1.25rem; /* text-lg */ font-weight: 700; /* font-bold */ margin-bottom: 0.75rem; /* mb-3 */ padding-bottom: 0.5rem; /* pb-2 */ border-bottom: 2px solid #5eead4; /* teal-300 */ font-family: 'Futura', 'Inter', sans-serif; }

        /* Action Buttons (Back, Clear) */
        .action-button {
             display: inline-block;
             margin-bottom: 1.5rem; /* mb-6 */
             padding: 0.5rem 1rem; /* py-2 px-4 */
             color: white;
             font-weight: 600; /* font-semibold */
             border-radius: 0.5rem; /* rounded-lg */
             text-decoration: none;
             transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
             box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); /* shadow */
             cursor: pointer;
             border: none;
             font-family: 'Avenir', 'Inter', sans-serif;
         }
         .action-button:hover {
             transform: translateY(-1px);
             box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* shadow-md */
         }
         .action-button i { margin-right: 0.5rem; /* mr-2 */ }
         .back-button { background-color: #64748b; /* bg-slate-500 */ }
         .back-button:hover { background-color: #475569; /* bg-slate-600 */ }
         .clear-button { background-color: #334155; /* bg-gray-700 */ margin-left: 0.5rem; }
         .clear-button:hover { background-color: #1e293b; /* bg-gray-800 */ }

        /* --- Test Date Pill Button Styles (Teal/Gray Colors) --- */
        #test-date-selection-area .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem; /* gap-3 */
            border: 1px solid #e5e7eb; /* border-gray-200 */
            padding: 1rem; /* p-4 */
            border-radius: 0.5rem; /* rounded-lg */
            min-height: 60px;
            background-color: #f9fafb; /* bg-gray-50 */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); /* shadow-inner */
        }
        .date-pill-button {
            /* Base styles */
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-weight: 500; /* Endret fra 600 for å matche original */
            font-size: 0.875rem; /* text-sm */
            padding: 0.25rem 0.75rem; /* px-3 py-1 */
            border-radius: 9999px; /* rounded-full */
            cursor: pointer;
            transition: all 150ms ease-in-out;
            border-width: 1px;
        }
        .date-pill-button i {
            font-size: 0.8em;
        }
        .date-pill-button:hover {
             /* Mer subtil hover-effekt som i originalen */
        }
        .date-pill-button:focus {
            outline: none;
            /* Kan justeres for å matche originalens fokus-ring hvis ønskelig */
            box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6;
        }
        .date-pill-visible {
            /* Included/Selected state - Teal */
            background-color: #ccfbf1; /* bg-teal-100 */
            color: #115e59; /* text-teal-800 */
            border-color: #5eead4; /* border-teal-300 */
        }
        .date-pill-visible:hover {
             background-color: #a7f3d0; /* hover:bg-teal-200 */
             border-color: #2dd4bf; /* hover:border-teal-400 */
        }
         .date-pill-visible:focus {
             /* Tilpass fokus-ring for teal hvis ønskelig */
             box-shadow: 0 0 0 2px white, 0 0 0 4px #2dd4bf; /* focus:ring-teal-400 */
         }
        .date-pill-hidden {
            /* Excluded/Deselected state - Light Gray */
            background-color: #e2e8f0; /* bg-slate-200 */
            color: #475569; /* text-slate-600 */
            border-color: #94a3b8; /* border-slate-400 */
            /* opacity: 0.9; */ /* Fjernet opacity for klarere skille */
        }
        .date-pill-hidden:hover {
            background-color: #cbd5e1; /* hover:bg-slate-300 */
            border-color: #64748b; /* hover:border-slate-500 */
        }
        .date-pill-hidden:focus {
             box-shadow: 0 0 0 2px white, 0 0 0 4px #9ca3af; /* focus:ring-gray-400 */
         }
        /* --- End Test Date Pill Button Styles --- */

        /* Plotly specific overrides */
        .js-plotly-plot .plotly { font-family: 'Avenir', sans-serif !important; }
        .js-plotly-plot .plotly .gtitle { font-family: 'Futura', sans-serif !important; font-size: 1rem !important; fill: var(--primary-color) !important; font-weight: 500 !important; }
        .js-plotly-plot .plotly .axistitle { font-size: 0.85rem !important; fill: var(--dark-gray) !important; font-weight: 500 !important; }
        .js-plotly-plot .plotly .tick text { font-size: 0.8rem !important; fill: var(--dark-gray) !important; }
        .js-plotly-plot .plotly .legendtext { font-size: 0.85rem !important; }
        .js-plotly-plot .plotly .annotation text { font-family: 'Futura', sans-serif !important; }

    </style>
</head>
<body class="bg-slate-100 text-slate-800 p-4 md:p-8">

    <div class="container mx-auto max-w-7xl bg-white p-6 md:p-10 rounded-xl shadow-xl">

        <div class="mb-6">
            <button id="back-to-screening-btn" class="action-button back-button">
                <i class="fas fa-arrow-left"></i> Back to Screening
            </button>
            <button id="clear-history-btn" class="action-button clear-button">
                <i class="fas fa-trash-alt"></i> Clear Saved Data
            </button>
        </div>

        <h1 class="text-4xl font-bold text-center text-teal-700 mb-8 font-[Futura,Inter,sans-serif]">
            Functional Shoulder Screening Analysis
        </h1>

        <div class="info-box text-center">
            <label for="upload-csv" class="file-input-button">
                <i class="fas fa-folder-open mr-2"></i>Select/Add Patient Data Files
            </label>
            <input type="file" id="upload-csv" accept=".csv" multiple>
            <p id="file-info" class="mt-3 text-sm text-slate-600">Select patient data files to begin analysis.</p>
            <div id="loading-spinner" class="hidden mt-3 text-teal-600">
                 <i class="fas fa-spinner fa-spin text-2xl"></i>
                 <span class="ml-2 align-middle">Processing files...</span>
            </div>
            <div id="error-message" class="mt-3 error-message"></div>
        </div>

        <div class="info-box">
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 gap-4">
                <h2 class="text-xl font-semibold text-teal-700 whitespace-nowrap font-[Futura,Inter,sans-serif]">Select Patient</h2>
                <div id="view-toggle-container" class="flex-shrink-0">
                    <button id="view-scatter-btn" class="view-toggle-button rounded-l-md active">
                        <i class="fas fa-chart-line mr-1"></i> Scatter View
                    </button>
                    <button id="view-bar-btn" class="view-toggle-button rounded-r-md border-l-0">
                        <i class="fas fa-chart-bar mr-1"></i> Bar Chart View
                    </button>
                </div>
            </div>
            <div class="flex flex-col md:flex-row md:items-center gap-4">
                <div class="flex-grow">
                    <input type="text" id="patient-search" placeholder="Search Patient ID (FP)..." class="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-teal-500 focus:border-transparent shadow-sm">
                </div>
                <div id="patient-button-container" class="flex flex-wrap gap-2 mt-2 md:mt-0 min-h-[40px] items-center">
                    <span class="text-slate-500 italic self-center">Upload files or load saved data to see patients.</span>
                </div>
            </div>
        </div>

        <div id="test-date-selection-area" class="mb-6">
             </div>

        <div id="output-area" class="mt-8">
            </div>

    </div>

    <script>
        // --- Global State Variables ---
        let allPatientData = {};
        let uniquePatientIds = [];
        let selectedPatientId = null;
        let currentViewMode = 'scatter'; // 'scatter' or 'bar'
        let testDateVisibility = {}; // { patientId: { dateStr: boolean, ... }, ... }
        let latestInjuredSide = null; // Store latest injured side for calculations

        // --- Constants ---
        const LOCAL_STORAGE_KEY = 'analysisAppDataHTML'; // Separate key for HTML version
        const LEFT_COLOR = '#1f77b4'; // Matplotlib Blue
        const RIGHT_COLOR = '#ff7f0e'; // Matplotlib Orange
        const NORMATIVE_THRESHOLDS = {
            'I': {'poor_max': 1.47, 'average_mid': 1.65, 'good_min': 1.85, 'excellent_min': 2.1},
            'Y': {'poor_max': 1.25, 'average_mid': 1.4,  'good_min': 1.6,  'excellent_min': 1.76},
            'T': {'poor_max': 1.15, 'average_mid': 1.25, 'good_min': 1.4,  'excellent_min': 1.58}
        };
        const NORM_ZONE_COLORS = { // Read from CSS variables if possible, fallback hardcoded
            poor: getComputedStyle(document.documentElement).getPropertyValue('--norm-poor-bg').trim() || 'rgba(252, 165, 165, 0.5)',
            average: getComputedStyle(document.documentElement).getPropertyValue('--norm-average-bg').trim() || 'rgba(252, 211, 77, 0.5)',
            good: getComputedStyle(document.documentElement).getPropertyValue('--norm-good-bg').trim() || 'rgba(167, 243, 208, 0.5)',
            excellent: getComputedStyle(document.documentElement).getPropertyValue('--norm-excellent-bg').trim() || 'rgba(52, 211, 153, 0.5)'
        };
        const POSITIONS = ['I', 'Y', 'T'];
        const METRIC_KEYS = { MAX_FORCE: 'Max Force (N)', RFD: 'RFD 100ms (N/s)', NORM: 'Max Force / BW' };
        const METRICS_DISPLAY_ORDER = [METRIC_KEYS.MAX_FORCE, METRIC_KEYS.RFD, METRIC_KEYS.NORM];

        // --- DOM References ---
        const uploadInput = document.getElementById('upload-csv');
        const fileInfo = document.getElementById('file-info');
        const patientSearchInput = document.getElementById('patient-search');
        const patientButtonContainer = document.getElementById('patient-button-container');
        const outputArea = document.getElementById('output-area');
        const loadingSpinner = document.getElementById('loading-spinner');
        const errorMessage = document.getElementById('error-message');
        const viewScatterBtn = document.getElementById('view-scatter-btn');
        const viewBarBtn = document.getElementById('view-bar-btn');
        const backButton = document.getElementById('back-to-screening-btn');
        const clearHistoryButton = document.getElementById('clear-history-btn');
        const testDateSelectionArea = document.getElementById('test-date-selection-area');

        // --- Plotly Configuration ---
        const plotlyConfig = {
            displaylogo: false,
            modeBarButtonsToRemove: ['sendDataToCloud', 'lasso2d', 'select2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestCartesian', 'hoverCompareCartesian'],
            modeBarButtonsToAdd: [{
                name: 'Download plot as PNG',
                icon: Plotly?.Icons?.camera, // Check if Plotly is loaded
                click: function(gd) {
                    if (!Plotly) return; // Check again
                    const titleText = (gd.layout.title?.text || 'plot').replace(/<br>/g, ' ');
                    Plotly.downloadImage(gd, { format: 'png', width: gd._fullLayout.width, height: gd._fullLayout.height, filename: titleText });
                }
            }]
        };

        // --- Helper Functions ---
        function calculatePercentageChange(latest, previous) {
            if (latest == null || previous == null || previous === 0) return null;
            return ((latest - previous) / Math.abs(previous)) * 100;
        }

        function formatValue(value, isNorm = false) {
            if (value == null) return '<span class="na">N/A</span>';
            return isNorm ? value.toFixed(2) : value.toFixed(1);
        }

        function formatChange(change) {
            if (change == null) return '<span class="na">N/A</span>';
            const sign = change >= 0 ? '+' : '';
            return `${sign}${change.toFixed(0)}%`;
        }

        function getChangeClass(change) {
            if (change == null) return 'na';
            if (change > 0) return 'change-pos';
            if (change < 0) return 'change-neg';
            return 'change-zero';
        }

        function calculateAxisRange(values, thresholds = null, annotations = null, topPaddingFactor = 0.15) {
            const validValues = values.filter(y => y != null && !isNaN(y));
            let yDataMin = validValues.length > 0 ? Math.min(...validValues) : 0;
            let yDataMax = validValues.length > 0 ? Math.max(...validValues) : 1;

            if (thresholds) {
                const thresholdValues = Object.values(thresholds).filter(v => typeof v === 'number');
                if (thresholdValues.length > 0) {
                    yDataMin = Math.min(yDataMin, ...thresholdValues);
                    yDataMax = Math.max(yDataMax, ...thresholdValues);
                }
            }

            if (annotations && annotations.length > 0) {
                let maxAnnotatedY = -Infinity;
                 annotations.forEach(ann => {
                     if (ann.y != null && !isNaN(ann.y)) {
                         let annTop = ann.y;
                         if (ann.yanchor === 'bottom') {
                             annTop += (ann.yshift || 0);
                             if ((ann.yshift || 0) > 10) annTop += (ann.font?.size || 12) * 1.2;
                         } else if (ann.yanchor === 'top') {
                             annTop -= (ann.yshift || 0);
                         } else { // Middle anchor
                             annTop += (ann.yshift || 0) + (ann.font?.size || 12) * 0.6;
                         }
                         maxAnnotatedY = Math.max(maxAnnotatedY, annTop);
                     }
                 });
                if (maxAnnotatedY > yDataMax) {
                    yDataMax = maxAnnotatedY;
                }
            }

            const yDataRange = yDataMax - yDataMin;
            const bottomPaddingValue = Math.max(yDataRange * 0.15, Math.abs(yDataMin) * 0.1, 0.5);
            const topPaddingValue = Math.max(yDataRange * topPaddingFactor, Math.abs(yDataMax) * topPaddingFactor, 1.0);

            let rangeMin = yDataMin - bottomPaddingValue;
            let rangeMax = yDataMax + topPaddingValue;

            if (yDataMin >= 0) rangeMin = Math.min(0, rangeMin);
            if (yDataMax <= 0 && yDataMin < 0) rangeMax = Math.max(0, rangeMax);
            else if (yDataMax <= 0) rangeMax = 0.5;

            if (rangeMin >= rangeMax) { rangeMin = rangeMax - 1; }
            if (rangeMin === rangeMax) { rangeMin -= 0.5; rangeMax += 0.5; }

            return [rangeMin, rangeMax];
        }

        function groupDataByDate(processedData) {
            if (!processedData) return {}; // Handle null input gracefully
            const dataByDate = {};
            processedData.forEach(r => {
                if (!(r['Test Date'] instanceof Date) || isNaN(r['Test Date'])) {
                    console.warn("Skipping record with invalid date during grouping:", r);
                    return;
                }
                const dateStr = r['Test Date'].toISOString().split('T')[0];

                if (!dataByDate[dateStr]) {
                    dataByDate[dateStr] = {
                        'Test Date': r['Test Date'],
                        'Weeks Since First': r['Weeks Since First'],
                        'Bodyweight (kg)': r['Bodyweight (kg)'],
                        'I': { [METRIC_KEYS.MAX_FORCE]: { Left: null, Right: null }, [METRIC_KEYS.RFD]: { Left: null, Right: null }, [METRIC_KEYS.NORM]: { Left: null, Right: null } },
                        'Y': { [METRIC_KEYS.MAX_FORCE]: { Left: null, Right: null }, [METRIC_KEYS.RFD]: { Left: null, Right: null }, [METRIC_KEYS.NORM]: { Left: null, Right: null } },
                        'T': { [METRIC_KEYS.MAX_FORCE]: { Left: null, Right: null }, [METRIC_KEYS.RFD]: { Left: null, Right: null }, [METRIC_KEYS.NORM]: { Left: null, Right: null } }
                    };
                }

                const pos = r['Position Clean'];
                const metric = r['Metric'];
                if (pos && dataByDate[dateStr][pos] && dataByDate[dateStr][pos][metric]) {
                    dataByDate[dateStr][pos][metric].Left = r['Left Value'] ?? dataByDate[dateStr][pos][metric].Left;
                    dataByDate[dateStr][pos][metric].Right = r['Right Value'] ?? dataByDate[dateStr][pos][metric].Right;
                }

                if(r['Bodyweight (kg)'] != null) dataByDate[dateStr]['Bodyweight (kg)'] = r['Bodyweight (kg)'];

                for (const p of POSITIONS) {
                    const bw = dataByDate[dateStr]['Bodyweight (kg)'];
                    const mfData = dataByDate[dateStr][p]?.[METRIC_KEYS.MAX_FORCE];
                    if (!mfData) continue;

                    let nKgL = null; let nKgR = null;
                    if (bw != null && bw > 0) {
                        if (mfData.Left != null) nKgL = mfData.Left / bw;
                        if (mfData.Right != null) nKgR = mfData.Right / bw;
                    }
                     if(dataByDate[dateStr][p]) {
                         dataByDate[dateStr][p][METRIC_KEYS.NORM] = { Left: nKgL, Right: nKgR };
                     }
                }
            });
            // Return as array sorted by date
            return Object.values(dataByDate).sort((a, b) => a['Test Date'] - b['Test Date']);
        }

        // Finds and sets the latest injured side from a list of records
        function findLatestInjuredSide(records) {
            let foundSide = null;
            if (records && records.length > 0) {
                for (let i = records.length - 1; i >= 0; i--) {
                    if (records[i]['Injured Side'] != null) {
                        foundSide = records[i]['Injured Side'];
                        break;
                    }
                }
            }
            latestInjuredSide = foundSide || 'Left'; // Default to 'Left'
            console.log("Latest injured side determined as:", latestInjuredSide);
        }

        // Gets unique test dates for a patient
        function getUniqueTestDates(patientId, dataStore = allPatientData) {
             if (!dataStore || !dataStore[patientId]) return [];
             const dateSet = new Set();
             dataStore[patientId].forEach(record => {
                 if (record['Test Date'] instanceof Date && !isNaN(record['Test Date'])) {
                     dateSet.add(record['Test Date'].toISOString().split('T')[0]);
                 }
             });
             return Array.from(dateSet).sort();
         }

        // --- Local Storage Functions ---
        function saveAnalysisStateToLocalStorage() {
            const stateToSave = {
                allPatientData: {},
                uniquePatientIds: uniquePatientIds,
                selectedPatientId: selectedPatientId,
                currentViewMode: currentViewMode,
                testDateVisibility: testDateVisibility
            };
            try {
                const dataWithIsoDates = JSON.parse(JSON.stringify(allPatientData));
                for (const pid in dataWithIsoDates) {
                    if (Array.isArray(dataWithIsoDates[pid])) {
                        dataWithIsoDates[pid].forEach(record => {
                            if (record['Test Date'] instanceof Date && !isNaN(record['Test Date'])) {
                                record['Test Date'] = record['Test Date'].toISOString();
                            } else if (typeof record['Test Date'] === 'string') {
                                // Assume already ISO string
                            } else {
                                record['Test Date'] = null;
                            }
                        });
                    }
                }
                stateToSave.allPatientData = dataWithIsoDates;
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
                // console.log('Analysis state saved to localStorage.');
            } catch (error) {
                console.error('Error saving analysis state to localStorage:', error);
                if(errorMessage) errorMessage.textContent = 'Could not save analysis state. Storage might be full.';
            }
        }

        function loadAnalysisStateFromLocalStorage() {
            try {
                const savedDataString = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedDataString) {
                    const savedState = JSON.parse(savedDataString);
                    console.log('Loading analysis state from localStorage.');

                    const loadedPatientData = savedState.allPatientData || {};
                    const loadedVisibility = savedState.testDateVisibility || {};

                    // Convert date strings back to Date objects
                    for (const pid in loadedPatientData) {
                        if (Array.isArray(loadedPatientData[pid])) {
                            loadedPatientData[pid].forEach(record => {
                                if (record['Test Date'] && typeof record['Test Date'] === 'string') {
                                    const parsedDate = new Date(record['Test Date']);
                                    record['Test Date'] = !isNaN(parsedDate) ? parsedDate : null;
                                } else if (!(record['Test Date'] instanceof Date)) {
                                    record['Test Date'] = null;
                                }
                            });
                            loadedPatientData[pid] = loadedPatientData[pid].filter(r => r['Test Date'] instanceof Date);
                            loadedPatientData[pid].sort((a, b) => a['Test Date'] - b['Test Date']);
                        }
                    }

                    allPatientData = loadedPatientData;
                    uniquePatientIds = savedState.uniquePatientIds || [];
                    currentViewMode = savedState.currentViewMode || 'scatter';
                    testDateVisibility = loadedVisibility;
                    selectedPatientId = savedState.selectedPatientId || null;

                    if (fileInfo) fileInfo.textContent = `${Object.keys(allPatientData).length} patient(s) loaded. Add more files or select a patient.`;

                    displayPatientButtons(); // Update UI
                    updateViewToggleButtons(); // Update view toggle

                    // If a patient was selected, display their data and find injured side
                    if (selectedPatientId && allPatientData[selectedPatientId]) {
                        console.log("Triggering display for loaded patient:", selectedPatientId);
                        selectPatient(selectedPatientId, true); // Pass true to indicate loading
                    } else {
                        console.log("No patient selected or patient data missing after load.");
                        if(testDateSelectionArea) testDateSelectionArea.innerHTML = '';
                        if(outputArea) outputArea.innerHTML = '';
                    }

                } else {
                    console.log('No analysis data found in localStorage.');
                    if (fileInfo) fileInfo.textContent = 'Select patient data files to begin analysis.';
                    displayPatientButtons(); // Display empty state
                }
            } catch (error) {
                console.error('Error loading analysis state from localStorage:', error);
                if(errorMessage) errorMessage.textContent = 'Could not load previous analysis state.';
                // Reset state on error
                allPatientData = {}; uniquePatientIds = []; selectedPatientId = null;
                currentViewMode = 'scatter'; testDateVisibility = {}; latestInjuredSide = null;
                displayPatientButtons();
            }
        }

        function clearAnalysisHistory() {
            if (confirm('Are you sure you want to clear all saved analysis data? This cannot be undone.')) {
                try {
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    // Reset all state variables
                    allPatientData = {}; uniquePatientIds = []; selectedPatientId = null;
                    latestInjuredSide = null; currentViewMode = 'scatter'; testDateVisibility = {};
                    // Clear UI elements
                    if(outputArea) outputArea.innerHTML = '';
                    if(testDateSelectionArea) testDateSelectionArea.innerHTML = '';
                    if(fileInfo) fileInfo.textContent = 'Select patient data files to begin analysis.';
                    if(patientSearchInput) patientSearchInput.value = '';
                    if(errorMessage) errorMessage.textContent = '';
                    displayPatientButtons();
                    switchViewMode('scatter'); // Reset view mode toggle
                    console.log('Analysis history cleared.');
                } catch (error) {
                    console.error('Error clearing analysis history:', error);
                    if(errorMessage) errorMessage.textContent = 'Could not clear saved data.';
                }
            }
        }

        // --- File Handling ---
        function handleFileUpload(event) {
            // Check if PapaParse is loaded
            if (typeof Papa === 'undefined' || !Papa) {
                if(errorMessage) errorMessage.textContent = 'Error: PapaParse library is not loaded. Cannot process CSV files.';
                if(loadingSpinner) loadingSpinner.classList.add('hidden');
                return;
            }

            const files = event.target.files;
            if (!files || files.length === 0) {
                if(fileInfo) fileInfo.textContent = 'No files selected.';
                return;
            }
            if(errorMessage) errorMessage.textContent = '';
            if(loadingSpinner) loadingSpinner.classList.remove('hidden');
            if(fileInfo) fileInfo.textContent = `Loading ${files.length} new file(s)...`;
            let filesProcessed = 0;
            const promises = [];
            let newPatientData = {}; // Temp storage for new data
            let skippedFileCount = 0;

            const currentData = { ...allPatientData }; // Copy current data

            for (const file of files) {
                const match = file.name.match(/ASH_([^_]+)_(\d{4}-\d{2}-\d{2})\.csv/i);
                if (!match || !match[1] || !match[2]) {
                    console.warn(`Filename format error, skipping: ${file.name}`);
                    filesProcessed++; skippedFileCount++; continue;
                }

                const patientId = match[1];
                const dateStringFromFile = match[2];
                const testDateFromFile = new Date(dateStringFromFile + 'T00:00:00');

                if (isNaN(testDateFromFile)) {
                    console.warn(`Invalid date in filename, skipping: ${file.name}`);
                    filesProcessed++; skippedFileCount++; continue;
                }

                let isDuplicateDate = false;
                const checkData = (dataObj) => {
                    if (dataObj[patientId]) {
                        return dataObj[patientId].some(record =>
                            record['Test Date'] instanceof Date && !isNaN(record['Test Date']) &&
                            record['Test Date'].toISOString().split('T')[0] === dateStringFromFile
                        );
                    } return false;
                };

                if (checkData(currentData) || checkData(newPatientData)) {
                    console.log(`Skipping duplicate file based on filename date: ${file.name}`);
                    filesProcessed++; skippedFileCount++;
                    promises.push(Promise.resolve({ skipped: true, filename: file.name }));
                    continue;
                }

                promises.push(new Promise((resolve, reject) => {
                    Papa.parse(file, {
                        header: true, skipEmptyLines: true, dynamicTyping: true,
                        complete: (results) => {
                            try {
                                if (!newPatientData[patientId]) newPatientData[patientId] = [];
                                results.data.forEach(row => {
                                    if (row && typeof row === 'object' && row['Metric'] && row['Position']) {
                                        let positionClean = String(row['Position']).replace(/ASH Test Position\s+/i, '').trim();
                                        if (POSITIONS.includes(positionClean)) {
                                            const leftVal = row['Left Value'] == null ? null : Number(row['Left Value']);
                                            const rightVal = row['Right Value'] == null ? null : Number(row['Right Value']);
                                            const bwVal = row['Bodyweight (kg)'] == null ? null : Number(row['Bodyweight (kg)']);
                                            newPatientData[patientId].push({
                                                ...row,
                                                'Left Value': isNaN(leftVal) ? null : leftVal,
                                                'Right Value': isNaN(rightVal) ? null : rightVal,
                                                'Bodyweight (kg)': isNaN(bwVal) ? null : bwVal,
                                                'Test Date': testDateFromFile,
                                                'Filename': file.name,
                                                'Position Clean': positionClean
                                            });
                                        } else { console.warn(`Invalid position '${row['Position']}' in ${file.name}.`); }
                                    } else { console.warn(`Invalid row structure in ${file.name}.`, row); }
                                });
                            } catch (parseError) {
                                console.error(`Error processing row data in ${file.name}:`, parseError);
                                reject(`Error processing data in ${file.name}`); return;
                            }
                            filesProcessed++; resolve({ skipped: false });
                        },
                        error: (error) => { filesProcessed++; reject(`Parsing error in ${file.name}: ${error.message}`); }
                    });
                }));
            }

            Promise.allSettled(promises).then(results => {
                if(loadingSpinner) loadingSpinner.classList.add('hidden');
                let filesAddedCount = 0;
                let patientsAddedCount = 0;
                let updatedPatientData = { ...allPatientData };
                let updatedVisibility = { ...testDateVisibility };

                for (const patientId in newPatientData) {
                    const isNewPatient = !updatedPatientData[patientId];
                    if (isNewPatient) {
                        updatedPatientData[patientId] = newPatientData[patientId];
                        patientsAddedCount++;
                    } else {
                        updatedPatientData[patientId] = [...updatedPatientData[patientId], ...newPatientData[patientId]];
                        updatedPatientData[patientId].sort((a, b) => a['Test Date'] - b['Test Date']);
                    }
                    filesAddedCount++;

                    if (!updatedVisibility[patientId]) updatedVisibility[patientId] = {};
                    const uniqueDates = getUniqueTestDates(patientId, updatedPatientData);
                    uniqueDates.forEach(dateStr => {
                        if (updatedVisibility[patientId][dateStr] === undefined) {
                            updatedVisibility[patientId][dateStr] = true;
                        }
                    });
                }

                allPatientData = updatedPatientData; // Update global variable
                testDateVisibility = updatedVisibility; // Update global variable
                uniquePatientIds = Object.keys(allPatientData).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

                displayPatientButtons();
                saveAnalysisStateToLocalStorage();

                const finalPatientCount = uniquePatientIds.length;
                let infoMsg = `${finalPatientCount} total patient(s). `;
                infoMsg += `Processed ${files.length} file(s). `;
                if (filesAddedCount > 0) {
                     infoMsg += `Added data for ${patientsAddedCount} new patient(s) and updated ${filesAddedCount - patientsAddedCount} existing patient(s). `;
                }
                if (skippedFileCount > 0) {
                    infoMsg += `Skipped ${skippedFileCount} file(s) due to format errors or duplicate dates. `;
                }
                if(fileInfo) fileInfo.textContent = infoMsg + 'Select a patient below.';

                const errors = results.filter(r => r.status === 'rejected').map(r => r.reason);
                if (errors.length > 0 && errorMessage) errorMessage.textContent = `Some files could not be processed: ${errors.join('; ')}`;

                // Refresh view if selected patient was updated
                if (selectedPatientId && newPatientData[selectedPatientId]) {
                    renderTestDateList(selectedPatientId);
                    displayPatientDataAndGraphs(selectedPatientId);
                } else if (selectedPatientId) {
                    renderTestDateList(selectedPatientId); // Still might need date list update
                }

            }).catch(err => {
                if(loadingSpinner) loadingSpinner.classList.add('hidden');
                if(errorMessage) errorMessage.textContent = `An unexpected error occurred: ${err.message}`;
                console.error("Unexpected error handling file uploads:", err);
                displayPatientButtons();
            });

            // Reset file input
            if (event.target) event.target.value = null;
        }

        // --- Patient Selection and UI Updates ---
        function displayPatientButtons() {
            if (!patientButtonContainer || !patientSearchInput) return;
            const searchTerm = patientSearchInput.value.toLowerCase();
            patientButtonContainer.innerHTML = ''; // Clear

            if (uniquePatientIds.length === 0) {
                if (loadingSpinner && loadingSpinner.classList.contains('hidden')) {
                    patientButtonContainer.innerHTML = '<span class="text-slate-500 italic self-center">Upload files or load saved data to see patients.</span>';
                }
                return;
            }

            const filteredIds = uniquePatientIds.filter(id => id.toLowerCase().includes(searchTerm));
            if (filteredIds.length === 0) {
                patientButtonContainer.innerHTML = '<span class="text-slate-500 italic self-center">No patients match search.</span>';
                return;
            }

            filteredIds.forEach(pid => {
                const button = document.createElement('button');
                button.textContent = pid;
                // Apply base classes and conditional 'selected' class
                button.className = `patient-button py-2 px-4 border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500`;
                if (pid === selectedPatientId) button.classList.add('selected');
                button.onclick = () => selectPatient(pid);
                patientButtonContainer.appendChild(button);
            });
        }

        function selectPatient(patientId, isLoading = false) {
            selectedPatientId = patientId;
            console.log(`Selected patient: ${patientId}`);
            displayPatientButtons(); // Update button styles

            findLatestInjuredSide(allPatientData[patientId]); // Find injured side on select

            initializeVisibility(patientId); // Ensure visibility state exists
            renderTestDateList(patientId); // Render date toggles

            displayPatientDataAndGraphs(patientId); // Render data (saves state inside)
        }

        // --- Test Date Visibility ---
        function initializeVisibility(patientId) {
            if (!testDateVisibility[patientId]) {
                testDateVisibility[patientId] = {};
            }
            const uniqueDates = getUniqueTestDates(patientId);
            uniqueDates.forEach(dateStr => {
                if (testDateVisibility[patientId][dateStr] === undefined) {
                    testDateVisibility[patientId][dateStr] = true; // Default to visible
                }
            });
        }

        function handleDateToggle(patientId, dateToToggle) {
            if (!testDateVisibility[patientId]) {
                console.error("Visibility state not initialized for patient:", patientId); return;
            }
            // Toggle the visibility state
            const currentVisibility = testDateVisibility[patientId][dateToToggle];
            testDateVisibility[patientId][dateToToggle] = !currentVisibility;
            console.log(`Toggled visibility for ${patientId} - ${dateToToggle} to ${!currentVisibility}`);

            // Re-render the date list to update button appearance
            renderTestDateList(patientId);

            // Update graphs/table based on the new visibility state
            displayPatientDataAndGraphs(patientId); // This will filter data and re-render (saves state inside)
        }

        function renderTestDateList(patientId) {
            if (!testDateSelectionArea) return;
            testDateSelectionArea.innerHTML = ''; // Clear previous list
            const uniqueDates = getUniqueTestDates(patientId);

            // Don't show the list if there's only one test date or none
            if (uniqueDates.length <= 1) {
                return;
            }

            initializeVisibility(patientId); // Ensure state exists

            // Create container for the date buttons with pill styling
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container'; // Use the class defined in CSS
            buttonContainer.innerHTML = '<h4 class="w-full text-sm font-semibold text-gray-700 mb-1">Toggle Test Dates:</h4>'; // Add a title

            // Create a pill button for each unique date
            uniqueDates.forEach(dateStr => {
                const isVisible = testDateVisibility[patientId]?.[dateStr] ?? true; // Get visibility state
                const button = document.createElement('button');
                button.type = 'button';
                // Apply base class and conditional visible/hidden class
                button.className = `date-pill-button ${isVisible ? 'date-pill-visible' : 'date-pill-hidden'}`;
                button.dataset.date = dateStr; // Store date string for reference

                // Create and prepend the icon
                const icon = document.createElement('i');
                // Use fa-check-circle for visible, fa-times for hidden
                icon.className = `fas ${isVisible ? 'fa-check-circle' : 'fa-times'}`;
                button.appendChild(icon); // Add icon first

                // Add the date text after the icon
                const textNode = document.createTextNode(dateStr);
                button.appendChild(textNode);

                // Set click handler to toggle visibility
                button.onclick = () => handleDateToggle(patientId, dateStr);

                buttonContainer.appendChild(button);
            });

            testDateSelectionArea.appendChild(buttonContainer); // Add the container to the page
            console.log("Rendered date pill list for", patientId);
        }


        // --- Data Processing and Display ---
        function getProcessedPatientData(patientId) {
            const patientRecords = allPatientData[patientId];
            if (!patientRecords || patientRecords.length === 0) return null;

            initializeVisibility(patientId);
            const visibleDateStrings = testDateVisibility[patientId]
                ? Object.keys(testDateVisibility[patientId]).filter(dateStr => testDateVisibility[patientId][dateStr])
                : getUniqueTestDates(patientId); // Fallback

            const visibleRecords = patientRecords.filter(record => {
                if (!(record['Test Date'] instanceof Date) || isNaN(record['Test Date'])) return false;
                const dateStr = record['Test Date'].toISOString().split('T')[0];
                return visibleDateStrings.includes(dateStr);
            });

            if (visibleRecords.length === 0) return [];

            visibleRecords.sort((a, b) => a['Test Date'] - b['Test Date']);

            const firstTestDate = visibleRecords[0]['Test Date'];
            if (!firstTestDate) return [];

            const processedData = visibleRecords.map(record => {
                const weeksSinceFirst = Math.round((record['Test Date'] - firstTestDate) / (1000 * 60 * 60 * 24 * 7));
                return { ...record, 'Weeks Since First': weeksSinceFirst };
            });
            return processedData;
        }

        function displayPatientDataAndGraphs(patientId) {
            if (!outputArea) return;
            saveAnalysisStateToLocalStorage(); // Save state whenever displaying
            outputArea.innerHTML = '<div class="text-center p-10"><i class="fas fa-spinner fa-spin text-teal-600 text-3xl"></i><p class="mt-2">Loading data and graphs...</p></div>';

            try {
                const processedData = getProcessedPatientData(patientId);

                if (!processedData) {
                    outputArea.innerHTML = `<p class="error-message text-center font-semibold">Could not find data for patient ${patientId}.</p>`;
                    latestInjuredSide = null; return;
                }

                const uniqueDates = getUniqueTestDates(patientId); // Get all dates for check

                // Get latest demographics (based on *all* data, using global latestInjuredSide)
                let demoHTML = '';
                if (allPatientData[patientId] && allPatientData[patientId].length > 0) {
                     const allRecordsForPatient = allPatientData[patientId];
                     let latestDemo = {};
                     for (let i = allRecordsForPatient.length - 1; i >= 0; i--) {
                         const record = allRecordsForPatient[i];
                         if (latestDemo['Age'] == null && record['Age'] != null) latestDemo['Age'] = record['Age'];
                         if (latestDemo['Gender'] == null && record['Gender'] != null) latestDemo['Gender'] = record['Gender'];
                         if (latestDemo['Sport'] == null && record['Sport'] != null) latestDemo['Sport'] = record['Sport'];
                         if (latestDemo['Bodyweight (kg)'] == null && record['Bodyweight (kg)'] != null) latestDemo['Bodyweight (kg)'] = record['Bodyweight (kg)'];
                         // Injured side is already set globally by findLatestInjuredSide
                         if (latestDemo['Age'] != null && latestDemo['Gender'] != null && latestDemo['Sport'] != null && latestDemo['Bodyweight (kg)'] != null) break;
                     }
                     latestDemo['Injured Side'] = latestInjuredSide; // Use the globally determined side

                     demoHTML = `
                         <div class="info-box">
                             <h2 class="text-xl font-semibold text-teal-700 mb-3 font-[Futura,Inter,sans-serif]">Demographic Information (Patient: ${patientId})</h2>
                             <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-x-4 gap-y-2 text-sm">
                                 <div><strong>Age:</strong> ${latestDemo['Age'] ?? 'N/A'}</div>
                                 <div><strong>Gender:</strong> ${latestDemo['Gender'] ?? 'N/A'}</div>
                                 <div><strong>Sport:</strong> ${latestDemo['Sport'] ?? 'N/A'}</div>
                                 <div><strong>Bodyweight (last):</strong> ${latestDemo['Bodyweight (kg)'] != null ? latestDemo['Bodyweight (kg)'].toFixed(1) + ' kg' : 'N/A'}</div>
                                 <div><strong>Injured Side (last):</strong> ${latestDemo['Injured Side'] ?? 'N/A'}</div>
                             </div>
                         </div>`;
                }

                // Handle case where no visible dates are selected
                if (processedData.length === 0) {
                     let message = uniqueDates.length > 1
                        ? `<p class="text-center text-slate-500 italic mt-6">No test dates selected to display. Please select dates above.</p>`
                        : `<p class="text-center text-slate-500 italic mt-6">No processed test data available for this patient.</p>`;
                     outputArea.innerHTML = demoHTML + message; // Show demographics + message
                     return;
                 }


                // --- Build Output HTML ---
                const dataGroupedByDate = groupDataByDate(processedData);
                if (Object.keys(dataGroupedByDate).length === 0) {
                     outputArea.innerHTML = demoHTML + `<p class="error-message text-center font-semibold">Could not group visible data for patient ${patientId}.</p>`;
                     return;
                 }

                let outputHTML = demoHTML; // Start with demographics

                // Add HTML structure based on view mode
                if (currentViewMode === 'scatter') {
                    outputHTML += renderScatterViewHTML(dataGroupedByDate);
                } else { // Bar chart view
                    outputHTML += renderBarChartViewHTML(dataGroupedByDate);
                }

                // Render the HTML structure
                outputArea.innerHTML = outputHTML;

                // Render Plotly graphs asynchronously
                setTimeout(() => {
                    try {
                        if (!Plotly) throw new Error("Plotly library not loaded."); // Check Plotly again
                        if (currentViewMode === 'scatter') {
                            renderScatterPlots(dataGroupedByDate);
                        } else {
                            renderBarCharts(dataGroupedByDate, latestInjuredSide);
                        }
                    } catch (plotError) {
                        console.error("Error rendering plots:", plotError);
                        // Attempt to find the output area again in case it was overwritten
                        const currentOutputArea = document.getElementById('output-area');
                        if (currentOutputArea) {
                             currentOutputArea.innerHTML += `<p class="error-message text-center mt-4">An error occurred while rendering graphs: ${plotError.message}</p>`;
                        }
                    }
                }, 50); // Small delay

            } catch (error) {
                console.error("Error displaying patient data:", error);
                outputArea.innerHTML = `<p class="error-message text-center font-semibold">An error occurred while processing data for patient ${patientId}.</p>`;
            }
        }

        // --- HTML Rendering Functions ---
        function renderScatterViewHTML(dataGroupedByDate) {
            let scatterHTML = `<h2 class="text-2xl font-semibold text-teal-700 mb-4 mt-6 text-center md:text-left font-[Futura,Inter,sans-serif]">Results Over Time (Scatter)</h2>`;
            POSITIONS.forEach(pos => {
                scatterHTML += `
                    <div class="graph-box">
                        <h3 class="graph-box-title">Position ${pos}</h3>
                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                            <div id="scatter-graph-${pos}-${METRIC_KEYS.MAX_FORCE}" class="plotly-graph-div"><div class="loading-placeholder">Loading graph...</div></div>
                            <div id="scatter-graph-${pos}-${METRIC_KEYS.RFD}" class="plotly-graph-div"><div class="loading-placeholder">Loading graph...</div></div>
                            <div id="scatter-graph-${pos}-${METRIC_KEYS.NORM}" class="plotly-graph-div"><div class="loading-placeholder">Loading graph...</div></div>
                        </div>
                    </div>`;
            });
            scatterHTML += renderSummaryTableHTML(dataGroupedByDate);
            return scatterHTML;
        }

        function renderBarChartViewHTML(dataGroupedByDate) {
            let barHTML = `<h2 class="text-2xl font-semibold text-teal-700 mb-4 mt-6 text-center md:text-left font-[Futura,Inter,sans-serif]">Results Over Time (Bar Chart)</h2>`;
            POSITIONS.forEach(pos => {
                barHTML += `
                    <div class="graph-box">
                        <h3 class="graph-box-title">Position ${pos}</h3>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                            <div id="bar-graph-${pos}-${METRIC_KEYS.MAX_FORCE}" class="plotly-graph-div"><div class="loading-placeholder">Loading graph...</div></div>
                            <div id="bar-graph-${pos}-${METRIC_KEYS.RFD}" class="plotly-graph-div"><div class="loading-placeholder">Loading graph...</div></div>
                        </div>
                    </div>`;
            });
            barHTML += renderSummaryTableHTML(dataGroupedByDate);
            return barHTML;
        }

        function renderSummaryTableHTML(dataGroupedByDate) {
             if (!dataGroupedByDate || dataGroupedByDate.length === 0) return '<p class="text-center text-slate-500 italic mt-6">No test data available for summary table.</p>';

             let tableHTML = `<div class="info-box mt-8">
                                  <h2 class="text-xl font-semibold text-teal-700 mb-4 font-[Futura]">Detailed Summary</h2>`;
             POSITIONS.forEach(pos => {
                 tableHTML += `<div class="summary-section">`;
                 tableHTML += `<h3 class="summary-section-title">Position ${pos} Summary</h3>`;
                 tableHTML += `<div class="overflow-x-auto">`;
                 tableHTML += `<table class="summary-table">`;
                 // Header Row 1 (Dates)
                 tableHTML += `<thead><tr><th class="metric-header">Metric</th>`;
                 dataGroupedByDate.forEach(testData => {
                     const dateStr = testData['Test Date'] instanceof Date && !isNaN(testData['Test Date']) ? testData['Test Date'].toLocaleDateString('en-CA') : 'Invalid Date';
                     const weekStr = testData['Weeks Since First'] !== null ? `(Week ${testData['Weeks Since First']})` : '';
                     tableHTML += `<th colspan="4" class="date-header">${dateStr}<br>${weekStr}</th>`;
                 });
                 tableHTML += `</tr>`;
                 // Header Row 2 (Sub-headers)
                 tableHTML += `<tr><th class="metric-header">&nbsp;</th>`;
                 dataGroupedByDate.forEach(() => {
                     tableHTML += `<th class="sub-header">L Val</th><th class="sub-header">R Val</th><th class="sub-header">L Ch%</th><th class="sub-header">R Ch%</th>`;
                 });
                 tableHTML += `</tr></thead>`;
                 // Table Body
                 tableHTML += `<tbody>`;
                 METRICS_DISPLAY_ORDER.forEach(metricKey => {
                     tableHTML += `<tr><td class="metric-label">${metricKey}</td>`;
                     for (let i = 0; i < dataGroupedByDate.length; i++) {
                         const currentTestData = dataGroupedByDate[i];
                         const previousTestData = i > 0 ? dataGroupedByDate[i - 1] : null;
                         const currentMetricData = currentTestData[pos]?.[metricKey];
                         const previousMetricData = previousTestData?.[pos]?.[metricKey];
                         const latestL = currentMetricData?.Left; const previousL = previousMetricData?.Left;
                         const changeL = calculatePercentageChange(latestL, previousL);
                         const latestR = currentMetricData?.Right; const previousR = previousMetricData?.Right;
                         const changeR = calculatePercentageChange(latestR, previousR);
                         tableHTML += `<td class="left-value-cell">${formatValue(latestL, metricKey === METRIC_KEYS.NORM)}</td>`;
                         tableHTML += `<td class="right-value-cell">${formatValue(latestR, metricKey === METRIC_KEYS.NORM)}</td>`;
                         tableHTML += `<td class="${getChangeClass(changeL)}">${formatChange(changeL)}</td>`;
                         tableHTML += `<td class="${getChangeClass(changeR)}">${formatChange(changeR)}</td>`;
                     }
                     tableHTML += `</tr>`;
                 });
                 tableHTML += `</tbody></table></div></div>`; // Close table, div, section
             });
             tableHTML += `<p class="text-xs text-slate-500 mt-4">* Change calculated vs. previous test date shown in the table.</p></div>`; // Close info-box
             return tableHTML;
         }

        // --- Plotting Functions ---
        function renderScatterPlots(dataGroupedByDate) {
            POSITIONS.forEach(pos => {
                createTimeScatter(dataGroupedByDate, `scatter-graph-${pos}-${METRIC_KEYS.MAX_FORCE}`, METRIC_KEYS.MAX_FORCE, pos, false);
                createTimeScatter(dataGroupedByDate, `scatter-graph-${pos}-${METRIC_KEYS.RFD}`, METRIC_KEYS.RFD, pos, false);
                createTimeScatter(dataGroupedByDate, `scatter-graph-${pos}-${METRIC_KEYS.NORM}`, METRIC_KEYS.NORM, pos, true);
            });
        }

        function renderBarCharts(dataGroupedByDate, injuredSide) {
             POSITIONS.forEach(pos => {
                 createTimeSeriesBarChart(dataGroupedByDate, `bar-graph-${pos}-${METRIC_KEYS.MAX_FORCE}`, METRIC_KEYS.MAX_FORCE, pos, injuredSide);
                 createTimeSeriesBarChart(dataGroupedByDate, `bar-graph-${pos}-${METRIC_KEYS.RFD}`, METRIC_KEYS.RFD, pos, injuredSide);
             });
         }

        function createTimeScatter(dataGrouped, elementId, yMetricKey, position, addNormBg) {
            const plotElement = document.getElementById(elementId);
            if (!plotElement) { console.error(`Element ${elementId} not found.`); return; }
            plotElement.innerHTML = ''; // Clear
            if (!Plotly) { plotElement.innerHTML = `<div class="error-message p-4 text-center">Plotly library not loaded.</div>`; return; }
            if (!dataGrouped || dataGrouped.length === 0) { plotElement.innerHTML = `<div class="loading-placeholder">No data for Position ${position}.</div>`; return; }

            const xIndex = dataGrouped.map((_, i) => i);
            const xWeeksNum = dataGrouped.map(d => d['Weeks Since First']);
            let yLeft = [], yRight = [], hoverTextLeft = [], hoverTextRight = [], yValuesForRange = [];
            let yAxisTitle = yMetricKey;

            dataGrouped.forEach((d, i) => {
                let valLeft = null, valRight = null;
                let metricData = d[position]?.[yMetricKey];
                if (yMetricKey === METRIC_KEYS.NORM) {
                    yAxisTitle = 'Max Force / BW (N/kg)'; metricData = d[position]?.[METRIC_KEYS.NORM];
                    valLeft = metricData?.Left; valRight = metricData?.Right;
                } else if (metricData) { valLeft = metricData.Left; valRight = metricData.Right; }
                yLeft.push(valLeft); yRight.push(valRight);
                if (valLeft != null) yValuesForRange.push(valLeft); if (valRight != null) yValuesForRange.push(valRight);
                hoverTextLeft.push(`Week: ${xWeeksNum[i]}<br>${yAxisTitle}: ${valLeft != null ? valLeft.toFixed(2) : 'N/A'} (L)`);
                hoverTextRight.push(`Week: ${xWeeksNum[i]}<br>${yAxisTitle}: ${valRight != null ? valRight.toFixed(2) : 'N/A'} (R)`);
            });

            const traces = [
                { x: xIndex, y: yLeft, mode: 'lines+markers', name: 'Left', line: { color: LEFT_COLOR, shape: 'spline', width: 2.5 }, marker: { color: LEFT_COLOR, size: 9, symbol: 'circle' }, text: hoverTextLeft, hoverinfo: 'text' },
                { x: xIndex, y: yRight, mode: 'lines+markers', name: 'Right', line: { color: RIGHT_COLOR, shape: 'spline', width: 2.5 }, marker: { color: RIGHT_COLOR, size: 9, symbol: 'square' }, text: hoverTextRight, hoverinfo: 'text' }
            ];
            let yRange = calculateAxisRange(yValuesForRange, addNormBg ? NORMATIVE_THRESHOLDS[position] : null);
            const layout = {
                xaxis: { title: 'Weeks Since First Test', tickmode: 'array', tickvals: xIndex, ticktext: xWeeksNum, showgrid: true, gridcolor: 'var(--medium-gray)', zeroline: false, titlefont: { size: 13 }, tickfont: { size: 11 } },
                yaxis: { title: { text: yAxisTitle, font: {size: 13}}, zeroline: true, gridcolor: 'var(--medium-gray)', range: yRange, tickfont: { size: 11 } },
                margin: { l: 60, r: 20, t: 20, b: 60 }, hovermode: 'closest',
                legend: { orientation: "h", yanchor: "bottom", y: -0.3, xanchor: "center", x: 0.5, font: { size: 11 } },
                shapes: [], paper_bgcolor: 'var(--white)', plot_bgcolor: 'var(--light-gray)',
                font: { family: 'Avenir, sans-serif', size: 12, color: 'var(--dark-gray)' }
            };

            if (addNormBg && NORMATIVE_THRESHOLDS[position]) {
                const thresholds = NORMATIVE_THRESHOLDS[position];
                const finalYRangeMin = layout.yaxis.range[0]; const finalYRangeMax = layout.yaxis.range[1];
                const zones = [
                     { y0: finalYRangeMin, y1: thresholds.poor_max, color: NORM_ZONE_COLORS.poor },
                     { y0: thresholds.poor_max, y1: thresholds.good_min, color: NORM_ZONE_COLORS.average },
                     { y0: thresholds.good_min, y1: thresholds.excellent_min, color: NORM_ZONE_COLORS.good },
                     { y0: thresholds.excellent_min, y1: finalYRangeMax, color: NORM_ZONE_COLORS.excellent }
                ];
                 zones.forEach(zone => {
                     const effectiveY0 = Math.max(zone.y0, finalYRangeMin); const effectiveY1 = Math.min(zone.y1, finalYRangeMax);
                     if (effectiveY1 > effectiveY0) {
                         layout.shapes.push({ type: 'rect', xref: 'paper', yref: 'y', x0: 0, y0: effectiveY0, x1: 1, y1: effectiveY1, fillcolor: zone.color, opacity: 0.5, layer: 'below', line: { width: 0 } });
                     }
                 });
            }
            try { Plotly.react(elementId, traces, layout, plotlyConfig); }
            catch (error) { console.error(`Error plotting scatter ${elementId}:`, error); plotElement.innerHTML = `<div class="error-message p-4 text-center">Could not plot graph: ${error.message}</div>`; }
        }

        function createTimeSeriesBarChart(dataGrouped, elementId, yMetricKey, position, injuredSide) {
            const plotElement = document.getElementById(elementId);
            if (!plotElement) { console.error(`Element ${elementId} not found.`); return; }
            plotElement.innerHTML = ''; // Clear
            if (!Plotly) { plotElement.innerHTML = `<div class="error-message p-4 text-center">Plotly library not loaded.</div>`; return; }
            if (!dataGrouped || dataGrouped.length === 0) { plotElement.innerHTML = `<div class="loading-placeholder">No data for Position ${position}.</div>`; return; }

            const xIndex = dataGrouped.map((_, i) => i);
            const xWeeksNum = dataGrouped.map(d => d['Weeks Since First']);
            let yLeft = [], yRight = [], changesLeft = [], changesRight = [], yValuesForRange = [];
            const healthySide = injuredSide === 'Left' ? 'Right' : 'Left';
            const injuredSideKey = injuredSide === 'Left' ? 'Left' : 'Right';
            const healthySideKey = healthySide;

            for (let i = 0; i < dataGrouped.length; i++) {
                const currentData = dataGrouped[i]; const previousData = i > 0 ? dataGrouped[i-1] : null;
                const currentMetricData = currentData[position]?.[yMetricKey]; const previousMetricData = previousData?.[position]?.[yMetricKey];
                const valLeft = currentMetricData?.Left; const valRight = currentMetricData?.Right;
                const prevLeft = previousMetricData?.Left; const prevRight = previousMetricData?.Right;
                yLeft.push(valLeft); yRight.push(valRight);
                changesLeft.push(calculatePercentageChange(valLeft, prevLeft)); changesRight.push(calculatePercentageChange(valRight, prevRight));
                if (valLeft != null) yValuesForRange.push(valLeft); if (valRight != null) yValuesForRange.push(valRight);
            }

            const traceLeft = { x: xIndex, y: yLeft, type: 'bar', name: 'Left', marker: { color: LEFT_COLOR }, width: 0.4, text: yLeft.map(v => v?.toFixed(1) ?? ''), textposition: 'inside', insidetextanchor: 'middle', textfont: { color: '#ffffff', size: 11, weight: 'bold' }, hoverinfo: 'x+y+name' };
            const traceRight = { x: xIndex, y: yRight, type: 'bar', name: 'Right', marker: { color: RIGHT_COLOR }, width: 0.4, text: yRight.map(v => v?.toFixed(1) ?? ''), textposition: 'inside', insidetextanchor: 'middle', textfont: { color: '#ffffff', size: 11, weight: 'bold' }, hoverinfo: 'x+y+name' };

            const annotations = [];
            const asymmetryAnnotationYShift = 35; const changeAnnotationYShift = 18;
            for (let i = 0; i < xIndex.length; i++) {
                const yL = yLeft[i]; const yR = yRight[i]; const changeL = changesLeft[i]; const changeR = changesRight[i];
                const currentMetricData = dataGrouped[i][position]?.[yMetricKey];
                const injuredValue = currentMetricData?.[injuredSideKey]; const healthyValue = currentMetricData?.[healthySideKey];
                let diff = null;
                if (healthyValue != null && injuredValue != null && healthyValue !== 0) { diff = ((injuredValue / healthyValue) * 100) - 100; }
                else if (healthyValue === 0 && injuredValue === 0) { diff = 0; }
                let asymmetryColor = '#94a3b8'; if (diff !== null) asymmetryColor = diff >= -10 ? '#16a34a' : '#dc2626';
                const asymmetryText = diff !== null ? `${diff >= 0 ? '+' : ''}${diff.toFixed(0)}%` : 'N/A';
                const maxY = Math.max(yL ?? -Infinity, yR ?? -Infinity);
                if (yL != null || yR != null) { annotations.push({ x: xIndex[i], y: maxY >= 0 ? maxY : 0, text: asymmetryText, showarrow: false, font: { color: asymmetryColor, size: 14, weight: 'bold' }, xanchor: 'center', yanchor: 'bottom', yshift: asymmetryAnnotationYShift }); }
                const colorL = changeL === null ? '#94a3b8' : (changeL >= 0 ? '#16a34a' : '#dc2626');
                const colorR = changeR === null ? '#94a3b8' : (changeR >= 0 ? '#16a34a' : '#dc2626');
                if (yL != null && i > 0) { annotations.push({ x: xIndex[i], y: maxY >= 0 ? maxY : 0, text: formatChange(changeL), showarrow: false, font: { color: colorL, size: 10 }, xanchor: 'center', yanchor: 'bottom', yshift: changeAnnotationYShift, xshift: -24 }); }
                if (yR != null && i > 0) { annotations.push({ x: xIndex[i], y: maxY >= 0 ? maxY : 0, text: formatChange(changeR), showarrow: false, font: { color: colorR, size: 10 }, xanchor: 'center', yanchor: 'bottom', yshift: changeAnnotationYShift, xshift: 24 }); }
            }

            let yRange = calculateAxisRange(yValuesForRange, null, annotations, 0.30);
            const layout = {
                barmode: 'group', bargap: 0.2, bargroupgap: 0.1,
                xaxis: { title: 'Weeks Since First Test', tickmode: 'array', tickvals: xIndex, ticktext: xWeeksNum, showgrid: false, zeroline: false, titlefont: { size: 13 }, tickfont: { size: 11 } },
                yaxis: { title: { text: yMetricKey, font: {size: 13}}, zeroline: true, gridcolor: 'var(--medium-gray)', range: yRange, tickfont: { size: 11 } },
                margin: { l: 60, r: 20, t: 60, b: 80 }, hovermode: 'closest',
                legend: { orientation: "h", yanchor: "bottom", y: -0.45, xanchor: "center", x: 0.5, font: { size: 11 } },
                annotations: annotations, paper_bgcolor: 'var(--white)', plot_bgcolor: 'var(--light-gray)',
                font: { family: 'Avenir, sans-serif', size: 12, color: 'var(--dark-gray)' },
                uniformtext: { mode: 'hide', minsize: 10 }
            };
            try { Plotly.react(elementId, [traceLeft, traceRight], layout, plotlyConfig); }
            catch (error) { console.error(`Error plotting bar ${elementId}:`, error); plotElement.innerHTML = `<div class="error-message p-4 text-center">Could not plot graph: ${error.message}</div>`; }
        }

        // --- View Mode Switching ---
        function updateViewToggleButtons() {
            if (!viewScatterBtn || !viewBarBtn) return;
            viewScatterBtn.classList.toggle('active', currentViewMode === 'scatter');
            viewBarBtn.classList.toggle('active', currentViewMode === 'bar');
        }

        function switchViewMode(mode) {
            if (mode === currentViewMode) return;
            currentViewMode = mode;
            updateViewToggleButtons();
            if (selectedPatientId) {
                displayPatientDataAndGraphs(selectedPatientId); // Re-render data (saves state)
            } else {
                if(outputArea) outputArea.innerHTML = ''; // Clear output if no patient
            }
            // No need to save state here, displayPatientDataAndGraphs handles it
            console.log("Switched view to:", currentViewMode);
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            if (uploadInput) uploadInput.addEventListener('change', handleFileUpload);
            if (patientSearchInput) patientSearchInput.addEventListener('input', displayPatientButtons);
            if (viewScatterBtn) viewScatterBtn.addEventListener('click', () => switchViewMode('scatter'));
            if (viewBarBtn) viewBarBtn.addEventListener('click', () => switchViewMode('bar'));
            if (backButton) {
                backButton.addEventListener('click', () => {
                    console.log('Back button clicked, saving state before navigation.');
                    saveAnalysisStateToLocalStorage(); // Save before leaving
                    window.location.href = '../screening.html'; // Navigate back
                });
            }
            if (clearHistoryButton) {
                clearHistoryButton.addEventListener('click', clearAnalysisHistory);
            }
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            loadAnalysisStateFromLocalStorage();
        });

    </script>

</body>
</html>
